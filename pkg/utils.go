package pkg

import (
	"bytes"
	"fmt"
	"net/http"
	"os/exec"
	"regexp"
	"strconv"
	"strings"
	"time"
)

func runCommand(name string, arg ...string) (string, error) {
	cmd := exec.Command(name, arg...)
	output, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(output)), nil
}

// fetchDockerLogsWithSelector retrieves logs from a container based on
// a provided name or numeric index. If name is non-empty, it tries to find
// a container with exactly that name and errors if none found. If useIndex is true,
// it tries to pick the container at that zero-based index and errors if out of range.
// If neither name nor index is provided, it falls back to the first running container.
func fetchDockerLogsWithSelector(name string, index int, useIndex bool, lines int) (string, error) {
	// List running containers as "<ID> <Name>\n"
	out, err := exec.Command("docker", "ps", "-a", "--format", "{{.ID}} {{.Names}}").Output()
	if err != nil {
		return "", fmt.Errorf("failed to list Docker containers: %w", err)
	}
	entries := strings.Split(strings.TrimSpace(string(out)), "\n")
	linesArg := "--tail=" + strconv.Itoa(lines)

	// If a name was specified, try to find it
	if name != "" {
		for _, entry := range entries {
			parts := strings.Fields(entry)
			if len(parts) < 2 {
				continue
			}
			if parts[1] == name {
				return getContainerLogs(parts[0], linesArg)
			}
		}
		return "", fmt.Errorf("no running container with name %q found", name)
	}

	// If an index was specified, try to use it
	if useIndex {
		if index < 0 || index >= len(entries) {
			return "", fmt.Errorf("container index %d out of range", index)
		}
		parts := strings.Fields(entries[index])
		if len(parts) >= 1 {
			return getContainerLogs(parts[0], linesArg)
		}
		return "", fmt.Errorf("failed to parse container entry at index %d", index)
	}

	// No selector provided: fallback to first container
	if len(entries) > 0 {
		parts := strings.Fields(entries[0])
		if len(parts) >= 1 {
			return getContainerLogs(parts[0], linesArg)
		}
	}

	return "", fmt.Errorf("no running containers found")
}

// getContainerLogs executes `docker logs` for the given container ID.
func getContainerLogs(containerID, linesArg string) (string, error) {
	var buf bytes.Buffer
	cmd := exec.Command("docker", "logs", linesArg, containerID)
	cmd.Stdout = &buf
	cmd.Stderr = &buf
	if err := cmd.Run(); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// formatBytes converts bytes to a human-readable string in B, kB, MB, GB, etc.
func formatBytes(b uint64) string {
	const base = 1024.0
	sizes := []string{"B", "kB", "MB", "GB", "TB", "PB"}
	f := float64(b)
	i := 0
	for f >= base && i < len(sizes)-1 {
		f /= base
		i++
	}
	// show two decimals for MB and above
	if i > 1 {
		return fmt.Sprintf("%.2f %s", f, sizes[i])
	}
	return fmt.Sprintf("%.0f %s", f, sizes[i])
}

func getStatus() (string, error) {
	startupStatus, err := runCommand("systemctl", "show", "secret-vm-startup", "--property=SubState", "--value")
	if err != nil {
		return "", fmt.Errorf("could not get secret-vm-startup status: %w", err)
	}

	if startupStatus == "start" {
		return "initializing", nil
	}

	if startupStatus == "failed" {
		return "init_failed", nil
	}

	dockerServiceStatus, err := runCommand("systemctl", "show", "secret-vm-docker-start", "--property=SubState", "--value")
	if err != nil {
		return "", fmt.Errorf("could not get secret-vm-docker-start status: %w", err)
	}

	switch dockerServiceStatus {
	case "failed":
		return "prep_failed", nil
	case "running":
		dockerPsOutput, err := runCommand("docker", "ps", "-q")
		if err != nil {
			return "", fmt.Errorf("failed to execute 'docker ps -q': %w", err)
		}

		if dockerPsOutput != "" {
			return "running", nil
		} else {
			return "preparing", nil
		}
	case "dead":
		journalOutput, _ := runCommand("journalctl", "-u", "secret-vm-docker-start", "--no-pager")

		if strings.Contains(journalOutput, "exited with code 0") {
			return "exited", nil
		} else {
			return "crashed", nil
		}
	}

	return "unknown", nil
}

// LogLine represents a single log line with its parsed timestamp.
// The Timestamp is used for sorting, while Text is the original log line.
type LogLine struct {
	Timestamp time.Time
	Text      string
}

var (
	// Matches lines like "... docker[763]: [56B blob data]".
	// These are placeholder lines generated by systemd when the log entry
	// was a binary blob instead of a readable string.
	blobDataRegex = regexp.MustCompile(`\sdocker\[[0-9]+\]: \[[0-9]+B blob data\]$`)

	// journalctl timestamp prefix, e.g. "Aug 27 07:58:24 ".
	journalPrefix = regexp.MustCompile(`^[A-Z][a-z]{2}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2}\s+`)

	// Docker `--timestamps` format: "2025-08-27T07:58:24.123456789Z"
	dockerTS = "2006-01-02T15:04:05.999999999Z07:00"
)

// =======================
// Systemd (journalctl)
// =======================

// fetchServicesLogs returns logs from systemd services `secret-vm-*`.
// The `--no-pager` flag is required: without it, journalctl may invoke
// a pager like `less`, which would cause the process to hang or cut output.
func fetchServicesLogs() (string, error) {
	var buf bytes.Buffer
	cmd := exec.Command("journalctl",
		"-u", "secret-vm-network-setup",
		"-u", "secret-vm-startup",
		"-u", "secret-vm-attest-rest",
		"-u", "secret-vm-docker-start",
		"--no-pager")
	cmd.Stdout = &buf
	cmd.Stderr = &buf
	if err := cmd.Run(); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// parseJournalOutput parses raw journalctl output into []LogLine for sorting.
// Blob-data lines are filtered out. The text remains unchanged (no year is added).
func parseJournalOutput(s string) []LogLine {
	lines := strings.Split(s, "\n")
	now := time.Now()
	var out []LogLine
	for _, line := range lines {
		l := strings.TrimSpace(line)
		if l == "" || blobDataRegex.MatchString(l) {
			continue
		}
		if !journalPrefix.MatchString(l) {
			continue
		}
		if len(l) < 16 {
			continue
		}
		tsStr := l[:15] // "Aug 27 07:58:24"
		parsed, err := time.ParseInLocation("Jan _2 15:04:05", tsStr, time.Local)
		if err != nil {
			continue
		}
		// Attach current year only for sorting purposes.
		parsed = time.Date(now.Year(), parsed.Month(), parsed.Day(),
			parsed.Hour(), parsed.Minute(), parsed.Second(), 0, time.Local)
		out = append(out, LogLine{Timestamp: parsed, Text: l})
	}
	return out
}

// =======================
// Docker logs
// =======================

// listAllDockerContainerNames returns the names of all containers
// (running and stopped) using `docker ps -a`.
func listAllDockerContainerNames() ([]string, error) {
	out, err := exec.Command("docker", "ps", "-a", "--format", "{{.Names}}").Output()
	if err != nil {
		return nil, fmt.Errorf("failed to list Docker containers: %w", err)
	}
	raw := strings.Split(strings.TrimSpace(string(out)), "\n")
	var names []string
	for _, n := range raw {
		n = strings.TrimSpace(n)
		if n != "" {
			names = append(names, n)
		}
	}
	return names, nil
}

// formatDockerAsJournal converts a docker log line into a journalctl-like format:
// "Aug 27 07:58:24 <host> <container>[pid]: <message>"
func formatDockerAsJournal(ts time.Time, host, container string, pid int, msg string) string {
	return fmt.Sprintf("%s %s %s[%d]: %s", ts.Local().Format("Jan 2 15:04:05"), host, container, pid, msg)
}
// fetchDockerLogsForContainer retrieves logs for a specific container with timestamps.
// It converts docker ISO timestamps into journalctl-like lines.
func fetchDockerLogsForContainer(container string, lines int, hostName string) ([]LogLine, error) {
	linesArg := "--tail=" + strconv.Itoa(lines)
	out, err := exec.Command("docker", "logs", "--timestamps", linesArg, container).Output()
	if err != nil {
		return nil, err
	}
	text := strings.TrimRight(string(out), "\n")
	if text == "" {
		return nil, nil
	}

	// Get container init PID once; if it fails, fallback to 0
	pid := getContainerInitPID(container)

	var res []LogLine
	for _, l := range strings.Split(text, "\n") {
		if l == "" {
			continue
		}
		space := strings.IndexByte(l, ' ')
		if space <= 0 {
			continue
		}
		tsRaw := l[:space]
		msg := strings.TrimSpace(l[space+1:])

		ts, err := time.Parse(dockerTS, tsRaw)
		if err != nil {
			if ts2, err2 := time.Parse(time.RFC3339, tsRaw); err2 == nil {
				ts = ts2
			} else {
				continue
			}
		}
		jline := formatDockerAsJournal(ts, hostName, container, pid, msg)
		res = append(res, LogLine{Timestamp: ts.Local(), Text: jline})
	}
	return res, nil
}

// fetchDockerLogsAll retrieves logs from all containers (running and stopped).
func fetchDockerLogsAll(lines int, hostName string) ([]LogLine, error) {
	names, err := listAllDockerContainerNames()
	if err != nil {
		return nil, err
	}
	var combined []LogLine
	for _, name := range names {
		ll, err := fetchDockerLogsForContainer(name, lines, hostName)
		if err != nil {
			continue
		}
		combined = append(combined, ll...)
	}
	return combined, nil
}

// writeLogsResponse writes log lines as plain text in journalctl format.
// Blob-data lines are filtered out again for safety.
func writeLogsResponse(w http.ResponseWriter, lines []LogLine) {
	var b strings.Builder
	for _, l := range lines {
		if blobDataRegex.MatchString(l.Text) {
			continue
		}
		b.WriteString(l.Text)
		b.WriteByte('\n')
	}
	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	w.Header().Set("X-Content-Type-Options", "nosniff")
	w.WriteHeader(http.StatusOK)
	_, _ = w.Write([]byte(b.String()))
}

// getContainerInitPID returns the host PID of the container's init process.
// We use `docker inspect -f '{{.State.Pid}}' <container>`.
func getContainerInitPID(container string) int {
	out, err := exec.Command("docker", "inspect", "-f", "{{.State.Pid}}", container).Output()
	if err != nil {
		return 0
	}
	s := strings.TrimSpace(string(out))
	pid, err := strconv.Atoi(s)
	if err != nil {
		return 0
	}
	return pid
}